
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lilmonk/elasticdump/cmd/backup.go (100.0%)</option>
				
				<option value="file1">github.com/lilmonk/elasticdump/cmd/restore.go (100.0%)</option>
				
				<option value="file2">github.com/lilmonk/elasticdump/cmd/root.go (50.0%)</option>
				
				<option value="file3">github.com/lilmonk/elasticdump/cmd/transfer.go (100.0%)</option>
				
				<option value="file4">github.com/lilmonk/elasticdump/internal/restore/restore.go (35.2%)</option>
				
				<option value="file5">github.com/lilmonk/elasticdump/internal/transfer/transfer.go (43.3%)</option>
				
				<option value="file6">github.com/lilmonk/elasticdump/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"

        "github.com/lilmonk/elasticdump/internal/transfer"
        "github.com/spf13/cobra"
)

// backupCmd represents the backup command
var backupCmd = &amp;cobra.Command{
        Use:   "backup",
        Short: "Backup Elasticsearch data to file",
        Long: `Backup Elasticsearch data, mappings, or settings to a file.
This is a convenient wrapper around the transfer command for backup operations.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if input == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("input is required")
                }</span>
                <span class="cov8" title="3">if output == "" </span><span class="cov5" title="2">{
                        return fmt.Errorf("output is required")
                }</span>

                <span class="cov1" title="1">config := transfer.Config{
                        Input:       input,
                        Output:      output,
                        Type:        dataType,
                        Limit:       limit,
                        Concurrency: concurrency,
                        Format:      format,
                        ScrollSize:  scrollSize,
                        Verbose:     verbose,
                        Username:    username,
                        Password:    password,
                }

                return transfer.Run(config)</span>
        },
}

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(backupCmd)

        // Backup flags (reuse the same variables from transfer command)
        backupCmd.Flags().StringVarP(&amp;input, "input", "i", "", "Source Elasticsearch cluster or index (required)")
        backupCmd.Flags().StringVarP(&amp;output, "output", "o", "", "Output file path (required)")
        backupCmd.Flags().StringVarP(&amp;dataType, "type", "t", "data", "Type of data to backup (data, mapping, settings)")
        backupCmd.Flags().IntVarP(&amp;limit, "limit", "l", 0, "Limit the number of records to backup (0 = no limit)")
        backupCmd.Flags().IntVarP(&amp;concurrency, "concurrency", "c", 4, "Number of concurrent operations")
        backupCmd.Flags().StringVarP(&amp;format, "format", "f", "ndjson", "Output format (json, ndjson)")
        backupCmd.Flags().IntVarP(&amp;scrollSize, "scrollSize", "s", 1000, "Size of the scroll for large datasets")
        backupCmd.Flags().StringVarP(&amp;username, "username", "u", "", "Elasticsearch username (optional)")
        backupCmd.Flags().StringVarP(&amp;password, "password", "p", "", "Elasticsearch password (optional)")

        // Mark required flags
        backupCmd.MarkFlagRequired("input")
        backupCmd.MarkFlagRequired("output")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/lilmonk/elasticdump/internal/restore"
        "github.com/spf13/cobra"
)

// restoreCmd represents the restore command
var restoreCmd = &amp;cobra.Command{
        Use:   "restore",
        Short: "Restore Elasticsearch data from file",
        Long: `Restore Elasticsearch data, mappings, or settings from a backup file.
This command reads data from a file and imports it into an Elasticsearch cluster.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if input == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("input file is required")
                }</span>
                <span class="cov8" title="3">if output == "" </span><span class="cov5" title="2">{
                        return fmt.Errorf("output cluster is required")
                }</span>

                <span class="cov1" title="1">config := restore.Config{
                        Input:       input,
                        Output:      output,
                        Type:        dataType,
                        Concurrency: concurrency,
                        Verbose:     verbose,
                        Username:    username,
                        Password:    password,
                }

                return restore.Run(config)</span>
        },
}

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(restoreCmd)

        // Restore flags
        restoreCmd.Flags().StringVarP(&amp;input, "input", "i", "", "Input file path (required)")
        restoreCmd.Flags().StringVarP(&amp;output, "output", "o", "", "Destination Elasticsearch cluster or index (required)")
        restoreCmd.Flags().StringVarP(&amp;dataType, "type", "t", "data", "Type of data to restore (data, mapping, settings)")
        restoreCmd.Flags().IntVarP(&amp;concurrency, "concurrency", "c", 4, "Number of concurrent operations")
        restoreCmd.Flags().StringVarP(&amp;username, "username", "u", "", "Elasticsearch username (optional)")
        restoreCmd.Flags().StringVarP(&amp;password, "password", "p", "", "Elasticsearch password (optional)")

        // Mark required flags
        restoreCmd.MarkFlagRequired("input")
        restoreCmd.MarkFlagRequired("output")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

var (
        verbose bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "elasticdump",
        Short: "A Go CLI tool to migrate data between Elasticsearch clusters",
        Long: `Elasticdump is a powerful CLI tool built in Go that allows you to:
- Migrate data between Elasticsearch clusters
- Backup and restore data
- Handle large datasets efficiently
- Support multiple output formats (JSON, NDJSON, etc.)
- Perform multi-threaded operations for faster processing`,
        Version: "1.0.0",
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        // Global flags
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/lilmonk/elasticdump/internal/transfer"
        "github.com/spf13/cobra"
)

var (
        input       string
        output      string
        dataType    string
        limit       int
        concurrency int
        format      string
        scrollSize  int
        username    string
        password    string
)

// transferCmd represents the transfer command
var transferCmd = &amp;cobra.Command{
        Use:   "transfer",
        Short: "Transfer data between Elasticsearch clusters",
        Long: `Transfer data, mappings, or settings between Elasticsearch clusters.
This command supports various transfer types and can handle large datasets efficiently.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov10" title="4">{
                if input == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("input is required")
                }</span>
                <span class="cov8" title="3">if output == "" </span><span class="cov5" title="2">{
                        return fmt.Errorf("output is required")
                }</span>

                <span class="cov1" title="1">config := transfer.Config{
                        Input:       input,
                        Output:      output,
                        Type:        dataType,
                        Limit:       limit,
                        Concurrency: concurrency,
                        Format:      format,
                        ScrollSize:  scrollSize,
                        Verbose:     verbose,
                        Username:    username,
                        Password:    password,
                }

                return transfer.Run(config)</span>
        },
}

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(transferCmd)

        // Transfer flags
        transferCmd.Flags().StringVarP(&amp;input, "input", "i", "", "Source Elasticsearch cluster or index (required)")
        transferCmd.Flags().StringVarP(&amp;output, "output", "o", "", "Destination Elasticsearch cluster or index (required)")
        transferCmd.Flags().StringVarP(&amp;dataType, "type", "t", "data", "Type of data to transfer (data, mapping, settings)")
        transferCmd.Flags().IntVarP(&amp;limit, "limit", "l", 0, "Limit the number of records to transfer (0 = no limit)")
        transferCmd.Flags().IntVarP(&amp;concurrency, "concurrency", "c", 4, "Number of concurrent operations")
        transferCmd.Flags().StringVarP(&amp;format, "format", "f", "json", "Output format (json, ndjson)")
        transferCmd.Flags().IntVarP(&amp;scrollSize, "scrollSize", "s", 1000, "Size of the scroll for large datasets")
        transferCmd.Flags().StringVarP(&amp;username, "username", "u", "", "Elasticsearch username (optional)")
        transferCmd.Flags().StringVarP(&amp;password, "password", "p", "", "Elasticsearch password (optional)")

        // Mark required flags
        transferCmd.MarkFlagRequired("input")
        transferCmd.MarkFlagRequired("output")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package restore

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"

        "github.com/elastic/go-elasticsearch/v8"
        "github.com/schollz/progressbar/v3"
)

// Config holds the configuration for restore operations
type Config struct {
        Input       string
        Output      string
        Type        string
        Concurrency int
        Verbose     bool
        Username    string
        Password    string
}

// Client wraps Elasticsearch client with additional functionality
type Client struct {
        *elasticsearch.Client
        URL string
}

// Document represents an Elasticsearch document for restore
type Document struct {
        Index  string                 `json:"_index"`
        Type   string                 `json:"_type,omitempty"`
        ID     string                 `json:"_id"`
        Source map[string]interface{} `json:"_source"`
}

// Run executes the restore operation
func Run(config Config) error <span class="cov7" title="10">{
        if config.Verbose </span><span class="cov1" title="1">{
                fmt.Printf("Starting restore from %s to %s\n", config.Input, config.Output)
                fmt.Printf("Type: %s, Concurrency: %d\n", config.Type, config.Concurrency)
        }</span>

        <span class="cov7" title="10">switch config.Type </span>{
        case "data":<span class="cov4" title="3">
                return restoreData(config)</span>
        case "mapping":<span class="cov1" title="1">
                return restoreMapping(config)</span>
        case "settings":<span class="cov1" title="1">
                return restoreSettings(config)</span>
        default:<span class="cov5" title="5">
                return fmt.Errorf("unsupported restore type: %s", config.Type)</span>
        }
}

// getBaseURL extracts the base URL from the input string
func getBaseURL(s string) string <span class="cov8" title="11">{
        // Remove any index name from the URL
        return strings.TrimSuffix(s, "/"+extractIndex(s))
}</span>

// createClient creates an Elasticsearch client from URL with optional authentication
func createClient(url, username, password string) (*Client, error) <span class="cov6" title="6">{
        cfg := elasticsearch.Config{
                Addresses: []string{url},
        }

        // Add authentication if provided
        if username != "" &amp;&amp; password != "" </span><span class="cov1" title="1">{
                cfg.Username = username
                cfg.Password = password
        }</span>

        <span class="cov6" title="6">client, err := elasticsearch.NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return &amp;Client{Client: client, URL: url}, nil</span>
}

// restoreData restores documents from file to Elasticsearch
func restoreData(config Config) error <span class="cov4" title="3">{
        destURL := getBaseURL(config.Output)
        // Create destination client
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        // Open input file
        <span class="cov4" title="3">file, err := os.Open(config.Input)
        if err != nil </span><span class="cov4" title="3">{
                return fmt.Errorf("failed to open input file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get file info for progress tracking
        fileInfo, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">var bar *progressbar.ProgressBar
        if !config.Verbose </span><span class="cov0" title="0">{
                bar = progressbar.DefaultBytes(fileInfo.Size(), "Restoring documents")
        }</span>

        // Create worker pool
        <span class="cov0" title="0">docChan := make(chan Document, config.Concurrency*2)
        var wg sync.WaitGroup

        index := extractIndex(config.Output)
        // Start workers
        for i := 0; i &lt; config.Concurrency; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for doc := range docChan </span><span class="cov0" title="0">{
                                if err := indexDocument(destClient, index, doc); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error indexing document %s: %v\n", doc.ID, err)
                                }</span>
                        }
                }()
        }

        // Read and process documents
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(docChan)

                scanner := bufio.NewScanner(file)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := scanner.Text()
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var doc Document
                        if err := json.Unmarshal([]byte(line), &amp;doc); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error parsing document: %v\n", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">docChan &lt;- doc

                        if bar != nil </span><span class="cov0" title="0">{
                                bar.Add(len(line))
                        }</span>
                }

                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error reading file: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">wg.Wait()

        if bar != nil </span><span class="cov0" title="0">{
                bar.Finish()
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Restore completed to %s\n", config.Output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// restoreMapping restores index mapping from file
func restoreMapping(config Config) error <span class="cov1" title="1">{
        // Read mapping from file
        data, err := os.ReadFile(config.Input)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read mapping file: %w", err)
        }</span>

        <span class="cov0" title="0">var mapping map[string]interface{}
        if err := json.Unmarshal(data, &amp;mapping); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse mapping: %w", err)
        }</span>

        // Create destination client
        <span class="cov0" title="0">destURL := getBaseURL(config.Output)
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        // Extract index from output URL
        <span class="cov0" title="0">index := extractIndex(config.Output)
        if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not extract index from output URL")
        }</span>

        <span class="cov0" title="0">return putMapping(destClient, index, mapping)</span>
}

// restoreSettings restores index settings from file
func restoreSettings(config Config) error <span class="cov1" title="1">{
        // Read settings from file
        data, err := os.ReadFile(config.Input)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read settings file: %w", err)
        }</span>

        <span class="cov0" title="0">var settings map[string]interface{}
        if err := json.Unmarshal(data, &amp;settings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse settings: %w", err)
        }</span>

        // Create destination client
        <span class="cov0" title="0">destURL := getBaseURL(config.Output)
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        // Extract index from output URL
        <span class="cov0" title="0">index := extractIndex(config.Output)
        if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not extract index from output URL")
        }</span>

        <span class="cov0" title="0">return putSettings(destClient, index, settings)</span>
}

// Helper functions

func extractIndex(url string) string <span class="cov10" title="21">{
        // Extract index name from URL like http://localhost:9200/myindex
        parts := strings.Split(url, "/")
        if len(parts) &gt; 3 </span><span class="cov8" title="13">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov7" title="8">return ""</span>
}

func indexDocument(client *Client, index string, doc Document) error <span class="cov1" title="1">{
        data, err := json.Marshal(doc.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use the index from the destination URL (extracted from client.URL)
        <span class="cov1" title="1">if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("output index cannot be empty")
        }</span>

        // Use Elasticsearch Go client for indexing
        <span class="cov1" title="1">res, err := client.Index(
                index,
                strings.NewReader(string(data)),
                client.Index.WithDocumentID(doc.ID),
                client.Index.WithContext(context.Background()),
                client.Index.WithRefresh("false"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(res.Body)
                return fmt.Errorf("indexing failed: [%s] %s", res.Status(), string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func putMapping(client *Client, index string, mapping map[string]interface{}) error <span class="cov1" title="1">{
        data, err := json.Marshal(mapping)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">res, err := client.Indices.PutMapping(
                []string{index},
                strings.NewReader(string(data)),
                client.Indices.PutMapping.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("put mapping failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func putSettings(client *Client, index string, settings map[string]interface{}) error <span class="cov1" title="1">{
        data, err := json.Marshal(settings)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">res, err := client.Indices.PutSettings(
                strings.NewReader(string(data)),
                client.Indices.PutSettings.WithIndex(index),
                client.Indices.PutSettings.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("put settings failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package transfer

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/elastic/go-elasticsearch/v8"
        "github.com/schollz/progressbar/v3"
)

// Config holds the configuration for transfer operations
type Config struct {
        Input       string
        Output      string
        Type        string
        Limit       int
        Concurrency int
        Format      string
        ScrollSize  int
        Verbose     bool
        Username    string
        Password    string
}

// Client wraps Elasticsearch client with additional functionality
type Client struct {
        *elasticsearch.Client
        URL string
}

// Document represents an Elasticsearch document
type Document struct {
        Index  string                 `json:"_index"`
        Type   string                 `json:"_type,omitempty"`
        ID     string                 `json:"_id"`
        Source map[string]interface{} `json:"_source"`
}

// Run executes the transfer operation
func Run(config Config) error <span class="cov5" title="6">{
        if config.Verbose </span><span class="cov1" title="1">{
                fmt.Printf("Starting transfer from %s to %s\n", config.Input, config.Output)
                fmt.Printf("Type: %s, Concurrency: %d, ScrollSize: %d\n",
                        config.Type, config.Concurrency, config.ScrollSize)
        }</span>

        <span class="cov5" title="6">sourceURL := getBaseURL(config.Input)
        sourceClient, err := createClient(sourceURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create source client: %w", err)
        }</span>

        <span class="cov5" title="6">switch config.Type </span>{
        case "data":<span class="cov3" title="3">
                return transferData(sourceClient, config)</span>
        case "mapping":<span class="cov1" title="1">
                return transferMapping(sourceClient, config)</span>
        case "settings":<span class="cov1" title="1">
                return transferSettings(sourceClient, config)</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported transfer type: %s", config.Type)</span>
        }
}

// getBaseURL extracts the base URL from the input string
func getBaseURL(s string) string <span class="cov8" title="16">{
        // Remove any index name from the URL
        return strings.TrimSuffix(s, "/"+extractIndex(s))
}</span>

// createClient creates an Elasticsearch client from URL with optional authentication
func createClient(url, username, password string) (*Client, error) <span class="cov7" title="14">{
        cfg := elasticsearch.Config{
                Addresses: []string{url},
        }

        // Add authentication if provided
        if username != "" &amp;&amp; password != "" </span><span class="cov1" title="1">{
                cfg.Username = username
                cfg.Password = password
        }</span>

        <span class="cov7" title="14">client, err := elasticsearch.NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="14">return &amp;Client{Client: client, URL: url}, nil</span>
}

// transferData transfers documents between clusters
func transferData(sourceClient *Client, config Config) error <span class="cov3" title="3">{
        // Parse index from input URL
        index := extractIndex(config.Input)
        if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not extract index from input URL")
        }</span>

        // Check if output is a file or Elasticsearch URL
        <span class="cov3" title="3">if isFile(config.Output) </span><span class="cov0" title="0">{
                return exportToFile(sourceClient, index, config)
        }</span>

        // Transfer to another Elasticsearch cluster
        <span class="cov3" title="3">destURL := getBaseURL(config.Output)
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        <span class="cov3" title="3">return transferBetweenClusters(sourceClient, destClient, index, config)</span>
}

// exportToFile exports data to a file
func exportToFile(client *Client, index string, config Config) error <span class="cov0" title="0">{
        file, err := os.Create(config.Output)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Get total count for progress bar
        total, err := getDocumentCount(client, index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get document count: %w", err)
        }</span>

        <span class="cov0" title="0">if config.Limit &gt; 0 &amp;&amp; config.Limit &lt; total </span><span class="cov0" title="0">{
                total = config.Limit
        }</span>

        <span class="cov0" title="0">var bar *progressbar.ProgressBar
        if !config.Verbose </span><span class="cov0" title="0">{
                bar = progressbar.DefaultBytes(int64(total), "Exporting documents")
        }</span>

        // Start scrolling
        <span class="cov0" title="0">scrollSize := min(config.ScrollSize, total)
        scrollID, docs, err := startScroll(client, index, scrollSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start scroll: %w", err)
        }</span>

        <span class="cov0" title="0">exported := 0
        for len(docs) &gt; 0 &amp;&amp; (config.Limit == 0 || exported &lt; config.Limit) </span><span class="cov0" title="0">{
                for _, doc := range docs </span><span class="cov0" title="0">{
                        if config.Limit &gt; 0 &amp;&amp; exported &gt;= config.Limit </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">if err := writeDocument(file, doc, config.Format); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write document: %w", err)
                        }</span>

                        <span class="cov0" title="0">exported++
                        if bar != nil </span><span class="cov0" title="0">{
                                bar.Add(1)
                        }</span>
                }

                <span class="cov0" title="0">if config.Limit &gt; 0 &amp;&amp; exported &gt;= config.Limit </span><span class="cov0" title="0">{
                        break</span>
                }

                // Continue scrolling
                <span class="cov0" title="0">scrollID, docs, err = continueScroll(client, scrollID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to continue scroll: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if bar != nil </span><span class="cov0" title="0">{
                bar.Finish()
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Exported %d documents to %s\n", exported, config.Output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// transferBetweenClusters transfers data between two Elasticsearch clusters
func transferBetweenClusters(sourceClient, destClient *Client, index string, config Config) error <span class="cov3" title="3">{
        destIndex := extractIndex(config.Output)
        if destIndex == "" </span><span class="cov0" title="0">{
                destIndex = index
        }</span>

        // Get total count for progress bar
        <span class="cov3" title="3">total, err := getDocumentCount(sourceClient, index)
        if err != nil </span><span class="cov3" title="3">{
                return fmt.Errorf("failed to get document count: %w", err)
        }</span>

        <span class="cov0" title="0">if config.Limit &gt; 0 &amp;&amp; config.Limit &lt; total </span><span class="cov0" title="0">{
                total = config.Limit
        }</span>

        <span class="cov0" title="0">var bar *progressbar.ProgressBar
        if !config.Verbose </span><span class="cov0" title="0">{
                bar = progressbar.DefaultBytes(int64(total), "Transferring documents")
        }</span>

        // Create worker pool
        <span class="cov0" title="0">docChan := make(chan Document, config.Concurrency*2)
        var wg sync.WaitGroup

        // Start workers
        for i := 0; i &lt; config.Concurrency; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for doc := range docChan </span><span class="cov0" title="0">{
                                if err := indexDocument(destClient, destIndex, doc); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error indexing document %s: %v\n", doc.ID, err)
                                }</span>
                                <span class="cov0" title="0">if bar != nil </span><span class="cov0" title="0">{
                                        bar.Add(1)
                                }</span>
                        }
                }()
        }

        // Start scrolling and send documents to workers
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(docChan)

                scrollID, docs, err := startScroll(sourceClient, index, config.ScrollSize)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to start scroll: %v\n", err)
                        return
                }</span>

                <span class="cov0" title="0">transferred := 0
                for len(docs) &gt; 0 &amp;&amp; (config.Limit == 0 || transferred &lt; config.Limit) </span><span class="cov0" title="0">{
                        for _, doc := range docs </span><span class="cov0" title="0">{
                                if config.Limit &gt; 0 &amp;&amp; transferred &gt;= config.Limit </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">docChan &lt;- doc
                                transferred++</span>
                        }

                        <span class="cov0" title="0">if config.Limit &gt; 0 &amp;&amp; transferred &gt;= config.Limit </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Continue scrolling
                        <span class="cov0" title="0">scrollID, docs, err = continueScroll(sourceClient, scrollID)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Failed to continue scroll: %v\n", err)
                                return
                        }</span>
                }
        }()

        <span class="cov0" title="0">wg.Wait()

        if bar != nil </span><span class="cov0" title="0">{
                bar.Finish()
        }</span>

        <span class="cov0" title="0">if config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Transfer completed to %s\n", config.Output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// transferMapping transfers index mapping
func transferMapping(sourceClient *Client, config Config) error <span class="cov1" title="1">{
        index := extractIndex(config.Input)
        if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not extract index from input URL")
        }</span>

        <span class="cov1" title="1">mapping, err := getMapping(sourceClient, index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get mapping: %w", err)
        }</span>

        <span class="cov1" title="1">if isFile(config.Output) </span><span class="cov0" title="0">{
                return writeToFile(config.Output, mapping)
        }</span>

        <span class="cov1" title="1">destURL := getBaseURL(config.Output)
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        <span class="cov1" title="1">destIndex := extractIndex(config.Output)
        if destIndex == "" </span><span class="cov0" title="0">{
                destIndex = index
        }</span>

        <span class="cov1" title="1">return putMapping(destClient, destIndex, mapping)</span>
}

// transferSettings transfers index settings
func transferSettings(sourceClient *Client, config Config) error <span class="cov1" title="1">{
        index := extractIndex(config.Input)
        if index == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not extract index from input URL")
        }</span>

        <span class="cov1" title="1">settings, err := getSettings(sourceClient, index)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get settings: %w", err)
        }</span>

        <span class="cov1" title="1">if isFile(config.Output) </span><span class="cov0" title="0">{
                return writeToFile(config.Output, settings)
        }</span>

        <span class="cov1" title="1">destURL := getBaseURL(config.Output)
        destClient, err := createClient(destURL, config.Username, config.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination client: %w", err)
        }</span>

        <span class="cov1" title="1">destIndex := extractIndex(config.Output)
        if destIndex == "" </span><span class="cov0" title="0">{
                destIndex = index
        }</span>

        <span class="cov1" title="1">return putSettings(destClient, destIndex, settings)</span>
}

// Helper functions

func extractIndex(url string) string <span class="cov10" title="30">{
        // Extract index name from URL like http://localhost:9200/myindex
        parts := strings.Split(url, "/")
        if len(parts) &gt; 3 </span><span class="cov9" title="28">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov2" title="2">return ""</span>
}

func isFile(path string) bool <span class="cov6" title="9">{
        return !strings.HasPrefix(path, "http://") &amp;&amp; !strings.HasPrefix(path, "https://")
}</span>

func getDocumentCount(client *Client, index string) (int, error) <span class="cov4" title="4">{
        // Use Elasticsearch client for count
        res, err := client.Count(
                client.Count.WithIndex(index),
                client.Count.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov3" title="3">defer res.Body.Close()

        if res.IsError() </span><span class="cov3" title="3">{
                return 0, fmt.Errorf("count request failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.NewDecoder(res.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">count, ok := result["count"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid count response")
        }</span>

        <span class="cov0" title="0">return int(count), nil</span>
}

func startScroll(client *Client, index string, size int) (string, []Document, error) <span class="cov1" title="1">{
        // Use Elasticsearch client for scroll search
        res, err := client.Search(
                client.Search.WithIndex(index),
                client.Search.WithScroll(time.Minute*5),
                client.Search.WithSize(size),
                client.Search.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("search failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return parseScrollResponse(res.Body)</span>
}

func continueScroll(client *Client, scrollID string) (string, []Document, error) <span class="cov1" title="1">{
        // Use Elasticsearch client for scroll continuation
        res, err := client.Scroll(
                client.Scroll.WithScrollID(scrollID),
                client.Scroll.WithScroll(time.Minute*5),
                client.Scroll.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("scroll failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return parseScrollResponse(res.Body)</span>
}

func parseScrollResponse(body io.Reader) (string, []Document, error) <span class="cov2" title="2">{
        var result map[string]interface{}
        if err := json.NewDecoder(body).Decode(&amp;result); err != nil </span><span class="cov1" title="1">{
                return "", nil, err
        }</span>

        <span class="cov1" title="1">scrollID, _ := result["_scroll_id"].(string)

        hits, ok := result["hits"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return scrollID, nil, nil
        }</span>

        <span class="cov1" title="1">hitsList, ok := hits["hits"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return scrollID, nil, nil
        }</span>

        <span class="cov1" title="1">var docs []Document
        for _, hit := range hitsList </span><span class="cov1" title="1">{
                hitMap, ok := hit.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">doc := Document{
                        Index:  hitMap["_index"].(string),
                        ID:     hitMap["_id"].(string),
                        Source: hitMap["_source"].(map[string]interface{}),
                }

                if t, exists := hitMap["_type"]; exists </span><span class="cov1" title="1">{
                        doc.Type = t.(string)
                }</span>

                <span class="cov1" title="1">docs = append(docs, doc)</span>
        }

        <span class="cov1" title="1">return scrollID, docs, nil</span>
}

func writeDocument(writer io.Writer, doc Document, format string) error <span class="cov3" title="3">{
        switch format </span>{
        case "json":<span class="cov1" title="1">
                return json.NewEncoder(writer).Encode(doc)</span>
        case "ndjson":<span class="cov1" title="1">
                data, err := json.Marshal(doc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">_, err = fmt.Fprintf(writer, "%s\n", data)
                return err</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported format: %s", format)</span>
        }
}

func indexDocument(client *Client, index string, doc Document) error <span class="cov1" title="1">{
        data, err := json.Marshal(doc.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use Elasticsearch Go client for indexing
        <span class="cov1" title="1">res, err := client.Index(
                index,
                strings.NewReader(string(data)),
                client.Index.WithDocumentID(doc.ID),
                client.Index.WithContext(context.Background()),
                client.Index.WithRefresh("false"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(res.Body)
                return fmt.Errorf("indexing failed: [%s] %s", res.Status(), string(body))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getMapping(client *Client, index string) (map[string]interface{}, error) <span class="cov2" title="2">{
        res, err := client.Indices.GetMapping(
                client.Indices.GetMapping.WithIndex(index),
                client.Indices.GetMapping.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer res.Body.Close()

        var result map[string]interface{}
        if err := json.NewDecoder(res.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func putMapping(client *Client, index string, mapping map[string]interface{}) error <span class="cov2" title="2">{
        // Extract the mapping for the specific index
        indexMapping, ok := mapping[index].(map[string]interface{})
        if !ok </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid mapping format")
        }</span>

        <span class="cov0" title="0">mappingData, ok := indexMapping["mappings"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no mappings found")
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(mappingData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := client.Indices.PutMapping(
                []string{index},
                strings.NewReader(string(data)),
                client.Indices.PutMapping.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("put mapping failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getSettings(client *Client, index string) (map[string]interface{}, error) <span class="cov2" title="2">{
        res, err := client.Indices.GetSettings(
                client.Indices.GetSettings.WithIndex(index),
                client.Indices.GetSettings.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer res.Body.Close()

        var result map[string]interface{}
        if err := json.NewDecoder(res.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func putSettings(client *Client, index string, settings map[string]interface{}) error <span class="cov2" title="2">{
        // Extract the settings for the specific index
        indexSettings, ok := settings[index].(map[string]interface{})
        if !ok </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid settings format")
        }</span>

        <span class="cov0" title="0">settingsData, ok := indexSettings["settings"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no settings found")
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(settingsData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res, err := client.Indices.PutSettings(
                strings.NewReader(string(data)),
                client.Indices.PutSettings.WithIndex(index),
                client.Indices.PutSettings.WithContext(context.Background()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("put settings failed: %s", res.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func writeToFile(filename string, data interface{}) error <span class="cov1" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        return json.NewEncoder(file).Encode(data)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/lilmonk/elasticdump/cmd"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
